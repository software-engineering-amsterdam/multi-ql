{
module Lexer   
open System   
open Parser   
open Microsoft.FSharp.Text.Lexing   
   
  
let qlwords = 
    [
        "form", FORM;
        "if", IF;
        "money", MONEY;
        "integer", INTEGER;
        "string", STRINGTYPE;
    ] |> Map.ofList

let ops =   
    [   
        "=",    EQ;   
        "<",    LT;   
        "<=",   LE;   
        ">",    GT;   
        ">=",   GE;   
    ] |> Map.ofList   
   
let conditionops = 
    [
        "&", AND;
        "&&", BITWISEAND; // NOT SURE ABOUT CORRECTNESS OF NAME
        "|", OR;
        "||", BITWISEOR;

    ] |> Map.ofList
}

let char        = ['a'-'z' 'A'-'Z']   
let digit       = ['0'-'9']   
let int         = '-'?digit+   
let float       = '-'?digit+ '.' digit+   
let identifier  = char(char|digit|['-' '_' '.'])*   
let whitespace  = [' ' '\t']   
let newline     = "\n\r" | '\n' | '\r'  
let operator    = ">" | ">=" | "<" | "<=" | "=" 
let condoperator = "&" | "&&" | "|" | "||" 
let colon            = ":"
let open_bracket      = "{"
let close_bracket     = "}"
let open_brace  = "("
let close_brace = ")"


rule tokenize = parse   
| whitespace    { tokenize lexbuf }   
| newline       { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf; }   
| int           { INT(Int32.Parse(LexBuffer<_>.LexemeString lexbuf)) }   
| float         { FLOAT(Double.Parse(LexBuffer<_>.LexemeString lexbuf)) }   
| operator      { ops.[LexBuffer<_>.LexemeString lexbuf] }   
| condoperator  { conditionops.[LexBuffer<_>.LexemeString lexbuf] }
| identifier    { match qlwords.TryFind(LexBuffer<_>.LexemeString lexbuf) with   
                  | Some(token) -> token   
                  | None -> ID(LexBuffer<_>.LexemeString lexbuf) }   
| ','           { COMMA }   
| ':'           { COLON }
| '{'           { OPEN_BRACKET }
| '}'           { CLOSE_BRACKET }
| '('           { OPEN_BRACE }
| ')'           { CLOSE_BRACE }
| eof           { EOF }