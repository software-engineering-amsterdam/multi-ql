%package org.uva.sea.ql.parser
%class Parser
%interface Tokens
%semantic org.uva.sea.ql.ast.ASTNode
%start top

%token BOOLEAN
%token DATE
%token DECIMAL
%token INT
%token MONEY
%token STRING

%token ';'
%token <Ident> IDENT
%token <Bool> BOOLEAN_LITERAL
%token <Int> INT_LITERAL
%token <Str> STRING_LITERAL
%token ':' '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')'
%token '{' '}'
%token IF ELSE
%token FORM

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <Form> form
%type block
%type statements
%type conditionalStatement
%type <Question> question
%type <Int> type
%type <Expr> expr

%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.expr.*;
%}

%%

top : form { result = $1; };

form : FORM IDENT block { $$ = new Form($2, $3); }
;

block : '{' statements '}' { $$ = $2; }
;

statements : question ';' statements
           | conditionalStatement ';' statements
           | /*empty*/
;

conditionalStatement : IF '(' expr ')' block ELSE block
                     | IF '(' expr ')' block
;

question : IDENT ':' STRING_LITERAL type      { $$ = new Question($1, $3, $4); }
         | IDENT ':' STRING_LITERAL type expr { $$ = new ComputedQuestion($1, $3, $4, $5); }
;

type : BOOLEAN { $$ = new Int(Tokens.BOOLEAN); }
     | DATE    { $$ = new Int(Tokens.DATE); }
     | DECIMAL { $$ = new Int(Tokens.DECIMAL); }
     | INT     { $$ = new Int(Tokens.INT); }
     | MONEY   { $$ = new Int(Tokens.MONEY); }
     | STRING  { $$ = new Int(Tokens.STRING); }
;

expr : '+' expr %prec UPLUS { $$ = new Pos($2); }
     | '-' expr %prec UMIN  { $$ = new Neg($2); }
     | '!' expr %prec UNOT  { $$ = new Not($2); }
     | expr '*' expr        { $$ = new Mul($1, $3); }
     | expr '/' expr        { $$ = new Div($1, $3); }
     | expr '+' expr        { $$ = new Add($1, $3); }
     | expr '-' expr        { $$ = new Sub($1, $3); }
     | expr EQ expr         { $$ = new Eq($1, $3); }
     | expr NEQ expr        { $$ = new NEq($1, $3); }
     | expr '>' expr        { $$ = new GT($1, $3); }
     | expr '<' expr        { $$ = new LT($1, $3); }
     | expr GEQ expr        { $$ = new GEq($1, $3); }
     | expr LEQ expr        { $$ = new LEq($1, $3); }
     | expr AND expr        { $$ = new And($1, $3); }
     | expr OR expr         { $$ = new Or($1, $3); }
     | IDENT                { $$ = $1; }
     | INT_LITERAL          { $$ = $1; }
     | BOOLEAN_LITERAL      { $$ = $1; }
     | STRING_LITERAL       { $$ = $1; }
     | '(' expr ')'         { $$ = $2; }
;
		 

%%
private Lexer lexer; 

private Form result;

public Parser(Lexer theLexer) {
  theLexer.nextToken();
  lexer = theLexer; 
}

public Form getResult() {
  return result;
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}
