/** Lexical elements **/

/* stuff to ignore */
!whitespace     : ' ' | '\t' | '\n' | '\r' ;
_line_comment   : '/' '/' {.} '\n' ;
_block_comment  : '/' '*' {. | '*'} '*' '/' ;
!comment        : _line_comment | _block_comment ;

/* literals */
integer_lit     : '0'-'9' {'0'-'9'} ;
str_lit         : '"' {.} '"' ;

/* number operators */
addop           : '+' ;
mulop           : '*' ;
subop           : '-' ;
divop           : '/' ;

/* logical operators */
andop           : '&' '&' ;
orop            : '|' '|' ;
notop           : '!' ;

/* comparison operators */
ltop            : '<' ;
leqop           : '<' '=' ;
gtop            : '>' ;
geqop           : '>' '=' ;
neqop           : '!' '=' ;
eqop            : '=' '=' ;

/* special characters */
lbrace          : '{' ;
rbrace          : '}' ;
lpar            : '(' ;
rpar            : ')' ;
col             : ':' ;
assign          : '=' ;

/* variable identifier */
ident           : ('a'-'z' | 'A'-'Z') {('a'-'z' | 'A'-'Z'| '0'-'9' | '_')} ;

/** Syntax elements **/

<< import (
    "ql/ast"
    "ql/token"
) >>

/* form, start symbol */
Form        : "form" VarId Block                        << ast.NewForm($1, $2, $0.(*token.Token).Pos) >> ;

/* types */
Type        : "integer"                                 << ast.NewIntType($0) >>
            | "boolean"                                 << ast.NewBoolType($0) >>
            | "string"                                  << ast.NewStringType($0) >>
            ;

/* literals */
Literal     : integer_lit                               << ast.NewIntLit($0) >>
            | StrLiteral
            | "true"                                    << ast.NewBoolLit(ast.TRUE, $0.(*token.Token).Pos) >>
            | "false"                                   << ast.NewBoolLit(ast.FALSE, $0.(*token.Token).Pos) >>
            ;

StrLiteral  : str_lit                                   << ast.NewStrLit($0) >> ; // need to refer to this from question, thus is separate production


/* variables */
VarDecl     : VarId col Type                            << ast.NewVarDecl($0, $2, $1.(*token.Token).Pos) >> ;
VarId       : ident                                     << ast.NewVarId($0) >> ;

/* expressions */
Expr        : addop Expr                                << ast.NewPos($1, $0.(*token.Token).Pos) >>
            | subop Expr                                << ast.NewNeg($1, $0.(*token.Token).Pos) >>
            | notop Expr                                << ast.NewNot($1, $0.(*token.Token).Pos) >>
            | Expr mulop Expr                           << ast.NewMul($0, $2, $1.(*token.Token).Pos) >>
            | Expr divop Expr                           << ast.NewDiv($0, $2, $1.(*token.Token).Pos) >>
            | Expr addop Expr                           << ast.NewAdd($0, $2, $1.(*token.Token).Pos) >>
            | Expr subop Expr                           << ast.NewSub($0, $2, $1.(*token.Token).Pos) >>
            | Expr eqop Expr                            << ast.NewEq($0, $2, $1.(*token.Token).Pos) >>
            | Expr neqop Expr                           << ast.NewNEq($0, $2, $1.(*token.Token).Pos) >>
            | Expr gtop Expr                            << ast.NewGT($0, $2, $1.(*token.Token).Pos) >>
            | Expr ltop Expr                            << ast.NewLT($0, $2, $1.(*token.Token).Pos) >>
            | Expr geqop Expr                           << ast.NewGEq($0, $2, $1.(*token.Token).Pos) >>
            | Expr leqop Expr                           << ast.NewLEq($0, $2, $1.(*token.Token).Pos) >>
            | Expr andop Expr                           << ast.NewAnd($0, $2, $1.(*token.Token).Pos) >>
            | Expr orop Expr                            << ast.NewOr($0, $2, $1.(*token.Token).Pos) >>
            | lpar Expr rpar                            << $1, nil >>
            | VarId                                     << ast.NewVarExpr($0) >>
            | Literal
            ;

IfStmt      : "if" lpar Expr rpar Block                 << ast.NewIf($2, $4, $0.(*token.Token).Pos) >>
            | "if" lpar Expr rpar Block "else" Block    << ast.NewIfElse($2, $4, $6, $0.(*token.Token).Pos) >>
            ;

Question    : StrLiteral VarDecl                        << ast.NewInputQuestion($0, $1) >> // input question
            | StrLiteral VarDecl assign Expr            << ast.NewComputedQuestion($0, $1, $3, $2.(*token.Token).Pos) >> // computed question
            ;

Stmt        : Question 
            | IfStmt
            ;
        
StmtList    : Stmt                                      << ast.NewStmtList($0) >>
            | StmtList Stmt                             << ast.AppendStmt($0, $1) >>
            ;

Block       : lbrace StmtList rbrace                    << $1, nil >>
            | lbrace rbrace                             << ast.NewEmptyStmtList($0.(*token.Token).Pos) >>
            ;
