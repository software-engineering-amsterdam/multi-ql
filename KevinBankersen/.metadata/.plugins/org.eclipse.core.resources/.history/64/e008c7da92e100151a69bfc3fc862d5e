package eu.bankersen.kevin.ql.context;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import eu.bankersen.kevin.ql.ast.Identifier;
import eu.bankersen.kevin.ql.ast.Variable;
import eu.bankersen.kevin.ql.ast.expr.BooleanExpr;
import eu.bankersen.kevin.ql.ast.expr.Expr;
import eu.bankersen.kevin.ql.ast.expr.logic.And;
import eu.bankersen.kevin.ql.ast.expr.logic.Eq;
import eu.bankersen.kevin.ql.ast.expr.logic.GEq;
import eu.bankersen.kevin.ql.ast.expr.logic.GT;
import eu.bankersen.kevin.ql.ast.expr.logic.LEq;
import eu.bankersen.kevin.ql.ast.expr.logic.LT;
import eu.bankersen.kevin.ql.ast.expr.logic.NEq;
import eu.bankersen.kevin.ql.ast.expr.logic.Not;
import eu.bankersen.kevin.ql.ast.expr.logic.Or;
import eu.bankersen.kevin.ql.ast.expr.math.Add;
import eu.bankersen.kevin.ql.ast.expr.math.Div;
import eu.bankersen.kevin.ql.ast.expr.math.Mul;
import eu.bankersen.kevin.ql.ast.expr.math.Neg;
import eu.bankersen.kevin.ql.ast.expr.math.Pos;
import eu.bankersen.kevin.ql.ast.expr.math.Sub;
import eu.bankersen.kevin.ql.ast.type.BooleanType;
import eu.bankersen.kevin.ql.ast.type.IntType;
import eu.bankersen.kevin.ql.ast.type.MoneyType;
import eu.bankersen.kevin.ql.ast.type.StringType;
import eu.bankersen.kevin.ql.ast.type.Type;
import eu.bankersen.kevin.ql.context.errors.ExprTypeError;
import eu.bankersen.kevin.ql.context.errors.NotDeclaredError;
import eu.bankersen.kevin.ql.context.errors.TypeCheckingError;

public class Context {

    private SymbolTable symbolTable;
    private final Set<TypeCheckingError> errorList;
    
    private Set<String> identifiers;
    private final Map<String, Set<String>> relations;

    // The types supported by the language.
    private final IntType intType = new IntType();
    private final MoneyType moneyType = new MoneyType();
    private final StringType strType = new StringType();
    private final BooleanType boolType = new BooleanType();


    public Context() {
	this.symbolTable = new SymbolTable();
	this.relations = new HashMap<>();
	this.identifiers = new HashSet<>();
	this.errorList = new HashSet<>();
    }
    
    // Evaluate Expressions within Expressions
    private Context evaluateExpr(Expr expr) {
	return expr.checkType(this);
    }
    
    private Context evaluateExpr(Expr lhs, Expr rhs) {
	return rhs.checkType(lhs.checkType(this));
    }

    // Mathematical Expressions
    public Context evaluate(Add operation) {

	Context context = evaluateExpr(operation.lhs(), operation.rhs());
	symbolTable = context.getSymbolTable();
	
	Type left = operation.lhs().getType(symbolTable);
	Type right = operation.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) && right.isSimilar(moneyType)) 
		|| (left.isSimilar(intType) && right.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, right));
	}
	return context;
    }

    public Context evaluate(Sub operation) {
	
	Context context = evaluateExpr(operation.lhs(), operation.rhs());
	symbolTable = context.getSymbolTable();

	Type left = operation.lhs().getType(symbolTable);
	Type right = operation.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) && right.isSimilar(moneyType)) 
		|| (left.isSimilar(intType) && right.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, right));
	}
	return context;
    }

    public Context evaluate(Div operation) {
	
	Context context = evaluateExpr(operation.lhs(), operation.rhs());
	symbolTable = context.getSymbolTable();

	Type left = operation.lhs().getType(symbolTable);
	Type right = operation.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) && right.isSimilar(intType)) 
		|| (left.isSimilar(intType) && right.isSimilar(moneyType))
		|| (left.isSimilar(intType) && right.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, right, intType));
	}
	return context;
    }

    public Context evaluate(Mul operation) {
	
	Context context = evaluateExpr(operation.lhs(), operation.rhs());
	symbolTable = context.getSymbolTable();

	Type left = operation.lhs().getType(symbolTable);
	Type right = operation.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) && right.isSimilar(intType)) 
		|| (left.isSimilar(intType) && right.isSimilar(moneyType))
		|| (left.isSimilar(intType) && right.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, right, intType));
	}
	return context;
    }

    public Context evaluate(Neg operation) {
	
	Context context = evaluateExpr(operation.lhs(), operation.rhs());
	symbolTable = context.getSymbolTable();

	Type left = operation.lhs().getType(symbolTable);
	Type right = operation.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) || left.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, right));
	}
	return context;
    }

    public Context evaluate(Pos operation) {
	
	Context context = evaluateExpr(operation.lhs());
	symbolTable = context.getSymbolTable();

	Type left = operation.lhs().getType(symbolTable);

	Boolean check = (left.isSimilar(moneyType) || left.isSimilar(intType));

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, boolType));
	}
	return context;
    }

    // Boolean Expression that Require Boolean
    public Context evaluate(Not operation) {
	
	Context context = evaluateExpr(operation.lhs());
	symbolTable = context.getSymbolTable();
	
	Type left = operation.lhs().getType(symbolTable);

	Boolean check = left.isSimilar(boolType);

	if (!check) {
	    context.addError(new ExprTypeError(operation.line(), left, boolType));  
	}
	return context;
    }

    public Context evaluate(Or operation) {
	return simpleBooleanCheck(operation);
    }

    public Context evaluate(And operation) {
	return simpleBooleanCheck(operation);
    }

    private Context simpleBooleanCheck(BooleanExpr expr) {
	Context context = evaluateExpr(expr.lhs());
	symbolTable = context.getSymbolTable();
	
	Type left = expr.lhs().getType(symbolTable);
	Type right = expr.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(boolType) && right.isSimilar(boolType));

	if (!check) {
	    context.addError(new ExprTypeError(expr.line(), left, right));  
	}
	return context;
    }


    //Boolean Expressions for Equality
    public Context evaluate(NEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    public Context evaluate(LT operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    public Context evaluate(LEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    public Context evaluate(GT operation) {
	return simpleBooleanEqualityCheck(operation);
    }


    public Context evaluate(GEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    public Context evaluate(Eq operation) {
	return simpleBooleanEqualityCheck(operation);
    }


    private Context simpleBooleanEqualityCheck(BooleanExpr expr) {
	Context context = evaluateExpr(expr.lhs(), expr.rhs());
	symbolTable = context.getSymbolTable();
	
	Type left = expr.lhs().getType(symbolTable);
	Type right = expr.rhs().getType(symbolTable);

	Boolean check = (left.isSimilar(right));

	if (!check) {
	    context.addError(new ExprTypeError(expr.line(), left, right));  
	}
	return context;
    }

    // Looking at Identifiers
    public Context evaluate(Identifier id) {
	System.out.println(id.name());
	if (!checkID(id.name())) {
	    addError(new NotDeclaredError(id.line(), id.name()));
	}
	return this;
    }
    
    // Looking at Variables
    public Context evaluate(Variable variable) {

	Context context = evaluateExpr(variable.expr());
	symbolTable = context.getSymbolTable();
	
	System.out.println(variable.getName());
	
	System.out.println(relations);
	
	Type var = variable.getType();
	Type expr = variable.expr().getType(symbolTable);
	
	if (!var.isCompatible(expr)) {
	    context.addError(new ExprTypeError(variable.line(), var, expr));
	}
	
	return context;
    }

    public SymbolTable getSymbolTable() {
	return symbolTable;
    }

    public Symbol getSymbol(String symbol) {
	return symbolTable.getSymbol(symbol);
    }

    public Boolean checkID(String name) {
	return symbolTable.checkID(name);
    }

    public void addSymbol(Boolean computed, String symbol, String question, Type type, Object value) {
	symbolTable.addSymbol(computed, symbol, question, type, value);
    }

    public void updateSymbol(String name, Object value) {
	symbolTable.updateSymbol(name, value);
    }

    public void setVisibility(String name, Boolean active) {
	symbolTable.setVisibility(name, active);
    }

    public void addError(TypeCheckingError error) {
	errorList.add(error);
    }

    public Set<TypeCheckingError> getErrors() {
	return errorList;

    }

}