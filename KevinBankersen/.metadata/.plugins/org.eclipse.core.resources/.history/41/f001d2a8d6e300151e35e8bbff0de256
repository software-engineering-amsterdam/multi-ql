package eu.bankersen.kevin.ql.typechecker.analytics;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

import eu.bankersen.kevin.ql.ast.AbstractVisitor;
import eu.bankersen.kevin.ql.ast.Identifier;
import eu.bankersen.kevin.ql.ast.expr.Expr;
import eu.bankersen.kevin.ql.ast.form.Body;
import eu.bankersen.kevin.ql.ast.form.Form;
import eu.bankersen.kevin.ql.ast.stat.ComputedQuestion;
import eu.bankersen.kevin.ql.ast.stat.ElseStatement;
import eu.bankersen.kevin.ql.ast.stat.IFStatement;
import eu.bankersen.kevin.ql.ast.stat.NormalQuestion;
import eu.bankersen.kevin.ql.typechecker.errors.CyclicDependencyError;
import eu.bankersen.kevin.ql.typechecker.errors.TypeCheckError;

public class CyclicAnalyzer extends AbstractVisitor {

    private final Set<TypeCheckError> errorList;

    // Hold values to track relations.
    private final Map<String, Set<String>> qRelations;
    private  Set<String> questionIDs;
    private final Map<Set<String>, Set<String>> ifRelations;
    private  LinkedList<Set<String>> ifIDs;

    public CyclicAnalyzer(Form form) {
	this.ifRelations = new HashMap<>();
	this.ifIDs = new LinkedList<>();
	this.ifIDs.add(new HashSet<>());
	this.qRelations = new HashMap<>();
	this.questionIDs = new HashSet<>();
	this.errorList = new HashSet<>();

	this.analyzeFromDependencies(form);
    }

    @Override
    public void visit(Form o) {
	o.body().accept(this);	
    }

    @Override
    public void visit(Body o) {
	o.statements().forEach(s -> s.accept(this));
    }

    @Override
    public void visit(IFStatement o) {
	analyzeIfStatement(o.expr(), o.body());
    }

    @Override
    public void visit(ElseStatement o) {
	analyzeIfStatement(o.expr(), o.body());
	o.elseBody().accept(this);
    }  
    
    // Analyzes the common part of a if/else statement.
    private void analyzeIfStatement(Expr expr, Body body) {
	questionIDs = new HashSet<>();
	expr.accept(this);
	
	if (!questionIDs.isEmpty()) {
	    Set<String> ifId = questionIDs;
	    ifIDs.add(new HashSet<>());
	    questionIDs = new HashSet<>();
	    body.accept(this);
	    defineIfRelation(ifId);
	} else {
	    body.accept(this);
	}
    }

    @Override
    public void visit(ComputedQuestion o) {
	registerForIFstatment(o.name());
	o.expr().accept(this);
	defineQuestionRelation(o.name()); 
    }

    @Override
    public void visit(NormalQuestion o) {
	questionIDs = new HashSet<>();
	registerForIFstatment(o.name());
	defineQuestionRelation(o.name()); 
    }

    @Override
    public void visit(Expr o) {
	o.lhs().accept(this);
	if (o.rhs() != null) {
	    o.rhs().accept(this);
	}
    }

    @Override
    public void visit(Identifier o) {
	questionIDs.add(o.name());
    }

    private void registerForIFstatment(String name) {
	Set<String> lastElement;
	lastElement = ifIDs.getLast();
	ifIDs.removeLast();
	lastElement.add(name);
	ifIDs.add(lastElement);
    }

    private void registerForIFstatment(Set<String> names) {
	Set<String> lastElement;
	lastElement = ifIDs.getLast();
	lastElement.addAll(names);
	ifIDs.add(lastElement);
    }

    // Define a relationship between Question and identifiers.
    private void defineQuestionRelation(String variable) {     	
	if (!questionIDs.isEmpty()) {
	    Set<String> data = questionIDs;
	    if (qRelations.containsKey(variable)) {
		data.addAll(qRelations.get(variable));    
	    } 
	    qRelations.put(variable, data);
	}
	questionIDs = new HashSet<>();
    }

    // Define a relationship between If-Statement and identifiers.
    private void defineIfRelation(Set<String> variable) {
	Set<String> data = ifIDs.getLast();
	ifIDs.removeLast();
	
	// Append the data to the parent if-statement.
	if (!ifIDs.isEmpty()) {  
	    registerForIFstatment(data);
	}	

	// Add the data to the current if-statement.
	if (ifRelations.containsKey(variable)) {
	    data.addAll(ifRelations.get(variable));    
	}

	ifRelations.put(variable, data);
    }

    public Set<TypeCheckError> getErrors() {
	return errorList;
    }

    private void addError(TypeCheckError error) {
	errorList.add(error);
    }

    // Algorithm to calculate dependencies between Questions
    private void analyzeFromDependencies(Form form) {
	this.visit(form);
	this.computeDependencies();
    }

    private void computeDependencies() {

	Map<String, Set<String>> computedDependencies = new HashMap<>();

	for (String var : qRelations.keySet()) {
	    Set<String> dependencies = qRelations.get(var);
	    int previousSize = 0;

	    while (dependencies.size() != previousSize) {
		previousSize = dependencies.size();

		for (String ref : dependencies.toArray(new String[dependencies.size()])) {
		    if (qRelations.containsKey(ref)) {
			dependencies.addAll(qRelations.get(ref));
		    }
		}
	    }
	    if (dependencies.contains(var)) {
		addError(new CyclicDependencyError(var, dependencies));
	    }
	    computedDependencies.put(var, dependencies);
	}
	System.out.println("comp " +computedDependencies);
	System.out.println("if " +ifRelations);
	this.analyzeDependencies(computedDependencies);
    }

    // Algorithm to calculate dependencies between If-statements
    private void analyzeDependencies(Map<String, Set<String>> computedDependencies) {
	Set<String> computedQuestions = computedDependencies.keySet();
	for (Set<String> ifVars : ifRelations.keySet()) {
	    for (String ifVar : ifVars) {
		if (computedDependencies.containsKey(ifVar)) {
		    if (containsAny(qRelations.get(ifVar), ifRelations.get(ifVars), computedQuestions)) {
			addError(new CyclicDependencyError(ifVars, computedDependencies.get(ifVar)));
		    }
		}
	    }
	}
    }

    private Boolean containsAny(Set<String> qSet, Set<String> ifSet, Set<String> comp) {
	qSet.removeAll(comp);
	return qSet.stream().anyMatch(ifSet::contains);
    }

}