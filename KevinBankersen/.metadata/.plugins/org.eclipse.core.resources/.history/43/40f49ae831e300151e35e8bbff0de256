package eu.bankersen.kevin.ql.context.typeanalyzer.copy;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import eu.bankersen.kevin.ql.ast.Identifier;
import eu.bankersen.kevin.ql.ast.expr.BooleanExpr;
import eu.bankersen.kevin.ql.ast.expr.Expr;
import eu.bankersen.kevin.ql.ast.expr.logic.And;
import eu.bankersen.kevin.ql.ast.expr.logic.Eq;
import eu.bankersen.kevin.ql.ast.expr.logic.GEq;
import eu.bankersen.kevin.ql.ast.expr.logic.GT;
import eu.bankersen.kevin.ql.ast.expr.logic.LEq;
import eu.bankersen.kevin.ql.ast.expr.logic.LT;
import eu.bankersen.kevin.ql.ast.expr.logic.NEq;
import eu.bankersen.kevin.ql.ast.expr.logic.Not;
import eu.bankersen.kevin.ql.ast.expr.logic.Or;
import eu.bankersen.kevin.ql.ast.expr.math.Add;
import eu.bankersen.kevin.ql.ast.expr.math.Div;
import eu.bankersen.kevin.ql.ast.expr.math.Mul;
import eu.bankersen.kevin.ql.ast.expr.math.Neg;
import eu.bankersen.kevin.ql.ast.expr.math.Pos;
import eu.bankersen.kevin.ql.ast.expr.math.Sub;
import eu.bankersen.kevin.ql.ast.form.Form;
import eu.bankersen.kevin.ql.ast.stat.ComputedQuestion;
import eu.bankersen.kevin.ql.ast.stat.ElseStatement;
import eu.bankersen.kevin.ql.ast.stat.IFStatement;
import eu.bankersen.kevin.ql.ast.stat.NormalQuestion;
import eu.bankersen.kevin.ql.ast.type.BooleanType;
import eu.bankersen.kevin.ql.ast.type.IntType;
import eu.bankersen.kevin.ql.ast.type.MoneyType;
import eu.bankersen.kevin.ql.ast.type.Type;
import eu.bankersen.kevin.ql.context.symboltable.SymbolTable;
import eu.bankersen.kevin.ql.typechecker.errors.CyclicDependencyError;
import eu.bankersen.kevin.ql.typechecker.errors.ExprTypeError;
import eu.bankersen.kevin.ql.typechecker.errors.NotDeclaredError;
import eu.bankersen.kevin.ql.typechecker.errors.TypeCheckingError;

public class Context implements ContextInterface {

    // Hold all relevant information.
    private final SymbolTable symbolTable;
    private final Set<TypeCheckingError> errorList;

    // Hold values to track relations.
    private Set<String> identifiers;
    private final Map<String, Set<String>> relations;

    // The constructor sets the data and calls a method to process the raw symbol table.
    public Context(Form form, SymbolTable symbolTable) {
	this.symbolTable = symbolTable;
	this.relations = new HashMap<>();
	this.identifiers = new HashSet<>();
	this.errorList = new HashSet<>();
	form.checkType(this);
    }
    
    // Mathematical Operations.
    @Override
    public Context evaluate(Add operation) {

	Context updatedContext = evaluateExpr(operation.lhs(), operation.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = operation.lhs().getType(updatedSymbolTable);
	Type right = operation.rhs().getType(updatedSymbolTable);

	Boolean check = isBothMoney(left, right) || isBothInt(left, right);

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), left, right));
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Sub operation) {

	Context updatedContext = evaluateExpr(operation.lhs(), operation.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = operation.lhs().getType(updatedSymbolTable);
	Type right = operation.rhs().getType(updatedSymbolTable);

	Boolean check = isBothMoney(left, right) || isBothInt(left, right);

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), left, right));
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Div operation) {

	Context updatedContext = evaluateExpr(operation.lhs(), operation.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = operation.lhs().getType(updatedSymbolTable);
	Type right = operation.rhs().getType(updatedSymbolTable);

	Boolean check = isMoneyInt(left, right) || isBothInt(left, right);

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), left, right, new IntType()));
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Mul operation) {

	Context updatedContext = evaluateExpr(operation.lhs(), operation.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = operation.lhs().getType(updatedSymbolTable);
	Type right = operation.rhs().getType(updatedSymbolTable);

	Boolean check = isMoneyInt(left, right) || isBothInt(left, right);

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), left, right, new IntType()));
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Neg operation) {

	Context updatedContext = evaluateExpr(operation.lhs(), operation.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type expr = operation.lhs().getType(updatedSymbolTable);

	Boolean check = expr.isCompatible(new IntType());

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), expr, expr));// second expr must go
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Pos operation) {

	Context updatedContext = evaluateExpr(operation.lhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type expr = operation.lhs().getType(updatedSymbolTable);

	Boolean check = expr.isCompatible(new IntType());

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), expr, expr)); // second expr must go
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Not operation) {

	Context updatedContext = evaluateExpr(operation.lhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type expr = operation.lhs().getType(updatedSymbolTable);

	Boolean check = expr.isSimilar(new BooleanType());

	if (!check) {
	    updatedContext.addError(new ExprTypeError(operation.line(), new BooleanType(), expr));  
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Or operation) {
	return simpleBooleanCheck(operation);
    }

    @Override
    public Context evaluate(And operation) {
	return simpleBooleanCheck(operation);
    }

    private Context simpleBooleanCheck(BooleanExpr expr) {
	Context updatedContext = evaluateExpr(expr.lhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = expr.lhs().getType(updatedSymbolTable);
	Type right = expr.rhs().getType(updatedSymbolTable);

	Boolean check = isBothBoolean(left, right);

	if (!check) {
	    updatedContext.addError(new ExprTypeError(expr.line(), left, right));  
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(NEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    @Override
    public Context evaluate(LT operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    @Override
    public Context evaluate(LEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    @Override
    public Context evaluate(GT operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    @Override
    public Context evaluate(GEq operation) {
	return simpleBooleanEqualityCheck(operation);
    }

    @Override
    public Context evaluate(Eq operation) {
	return simpleBooleanEqualityCheck(operation);
    }


    private Context simpleBooleanEqualityCheck(BooleanExpr expr) {
	Context updatedContext = evaluateExpr(expr.lhs(), expr.rhs());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type left = expr.lhs().getType(updatedSymbolTable);
	Type right = expr.rhs().getType(updatedSymbolTable);

	Boolean check = (left.isSimilar(right));

	if (!check) {
	    updatedContext.addError(new ExprTypeError(expr.line(), left, right));  
	}
	return updatedContext;
    }

    @Override
    public Context evaluate(Identifier id) {
	identifiers.add(id.name());

	if (!symbolTable.checkID(id.name())) {
	    addError(new NotDeclaredError(id.line(), id.name()));
	}
	return this;
    }
    
    @Override
    public Context evaluate(ComputedQuestion question) {
	identifiers.clear();
	Context updatedContext = evaluateExpr(question.expr());
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();
	updatedContext.defineRelation(question.name()); 
	
	Type var = question.type();
	Type expr = question.expr().getType(updatedSymbolTable);

	if (!var.isCompatible(expr)) {
	    updatedContext.addError(new ExprTypeError(question.line(), var, expr));
	}

	return updatedContext;
    }
    
    @Override
    public Context evaluate(NormalQuestion question) {
	identifiers.clear();
	return this;
    }

    @Override
    public Context evaluate(IFStatement ifStat) {
	Context updatedContext = evaluateExpr(ifStat.expr());
	updatedContext = ifStat.body().checkType(updatedContext);
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type expr = ifStat.expr().getType(updatedSymbolTable);
	
	if (!expr.isCompatible(new BooleanType())) {
	    updatedContext.addError(new ExprTypeError(ifStat.line(), expr, new BooleanType()));
	}
	return updatedContext;
    }
    
    @Override
    public Context evaluate(ElseStatement elseStat) {
	Context updatedContext = evaluateExpr(elseStat.expr());
	updatedContext = elseStat.body().checkType(updatedContext);
	updatedContext = elseStat.elseBody().checkType(updatedContext);
	SymbolTable updatedSymbolTable = updatedContext.getSymbolTable();

	Type expr = elseStat.expr().getType(updatedSymbolTable);
	
	if (!expr.isCompatible(new BooleanType())) {
	    updatedContext.addError(new ExprTypeError(elseStat.line(), expr, new BooleanType()));
	}
	return updatedContext;
    }

    // Evaluate Expressions within Expressions.
    private Context evaluateExpr(Expr expr) {
	return expr.checkType(this);
    }

    private Context evaluateExpr(Expr lhs, Expr rhs) {
	return rhs.checkType(lhs.checkType(this));
    }
    
    // Functions for checking equality
    private boolean isBothMoney(Type left, Type right) {
	return isBothTypeX(left, right, new MoneyType());
    }
    
    private boolean isBothInt(Type left, Type right) {
	return isBothTypeX(left, right, new IntType());
    }
    
    private boolean isBothBoolean(Type left, Type right) {
	return isBothTypeX(left, right, new BooleanType());
    }
    
    private boolean isBothTypeX(Type left, Type right, Type match) {
	return left.isSimilar(match) && right.isSimilar(match);
    }
    
    private boolean isMoneyInt(Type left, Type right) {
	Type moneyType = new MoneyType();
	Type intType = new IntType();
	return left.isSimilar(moneyType) && right.isSimilar(intType)
		|| left.isSimilar(intType) && right.isSimilar(moneyType);
    }
    
    
    // Define a relationship between Question and identifiers.
    private void defineRelation(String variable) {
	Set<String> data = identifiers;
	if (relations.containsKey(variable)) {
	    data.addAll(relations.get(variable));    
	} 
	relations.put(variable, data);
	identifiers = new HashSet<>();
    }

    public SymbolTable getSymbolTable() {
	return symbolTable;
    }

    public Set<TypeCheckingError> getErrors() {
	return errorList;
    }
    
    private void addError(TypeCheckingError error) {
	errorList.add(error);
    }

    // Algorithm to calculate dependencies between Questions
    public void analyzeDependancies() {
	for (String var : relations.keySet()) {
	    Set<String> dependencies = relations.get(var);
	    int oldSize = 0;

	    while (dependencies.size() != oldSize) {
		oldSize = dependencies.size();	
		for (String ref : dependencies.toArray(new String[dependencies.size()])) {
		    if (relations.get(ref) != null) {
			dependencies.addAll(relations.get(ref));
		    }
		}
	    }
	    if (dependencies.contains(var)) {
		addError(new CyclicDependencyError(var));
	    }
	}
    }
}