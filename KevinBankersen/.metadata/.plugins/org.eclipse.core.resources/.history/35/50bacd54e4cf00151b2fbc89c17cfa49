grammar QL;

@parser::header
{

import eu.bankersen.kevin.ql.ast.expr.*;
import eu.bankersen.kevin.ql.ast.expr.logic.*;
import eu.bankersen.kevin.ql.ast.expr.math.*;
import eu.bankersen.kevin.ql.ast.stat.*;
import eu.bankersen.kevin.ql.ast.form.*;
import eu.bankersen.kevin.ql.ast.var.*;
}

file :  form* EOF
;

form returns [Form result]
	:	('Form'|'form') + ID + block { $result = new Form($ID.text, $block.result); }
	;

block returns [Block result]
	@init {
		$result = new Block(); //Must be set at initialisation, otherwise null reference
	}
	: '{' + (ifStat[$result] | question[$result] )+ '}'
	;

question[Block result]
	:	ID + STR + TYPE=(BOOLEAN|STRING|INTEGER) 
	
	{  
		switch ($TYPE.type) {
			case BOOLEAN:	$result.add(new Question(new BooleanVariable($ID.text), $STR.text));
			case STRING:	$result.add(new Question(new StringVariable($ID.text), $STR.text));
			case INTEGER:	$result.add(new Question(new IntegerVariable($ID.text), $STR.text));
		}
	}
	;

ifStat[Block arg]
	:	'if' + '(' + orExpr + ')' + block 
	{ 
		$arg.add(new IFStat($orExpr.result, $block.result));
	}
	;

addExpr returns [Expr result]
	:	lhs=mulExpr { $result=$lhs.result; } ( op=('+' | '-') rhs=mulExpr
	{ 
		switch($op.text){
			case "+": $result = new Add($result, $rhs.result);
			case "-": $result = new Sub($result, $rhs.result);      
		}
	})*
	;

mulExpr returns [Expr result]
	:	lhs=unExpr { $result=$lhs.result; } ( op=( '*' | '/' ) rhs=unExpr 
	{ 
		switch($op.text){
			case "+": $result = new Mul($result, $rhs.result);
			case "-": $result = new Div($result, $rhs.result);      
		}
	})*
	;


unExpr returns [Expr result]
	:	'+' x=unExpr { $result = new Pos($x.result); }
	|	'-' x=unExpr { $result = new Neg($x.result); }
	|	'!' x=unExpr { $result = new Not($x.result); }
	|	y=primary    { $result = $y.result; }
	;    

primary returns [Expr result]
	:	literal
	//|	identifier //Maybe make a variable class?
	|	'(' orExpr ')'
	;

literal
	:	intLiteral 
	|	strLiteral 
	|	boolLiteral
	;
	
intLiteral returns [Expr result]
	: INT { $result = new intLiteral(Integer.valueOf($INT.text)); }
	;
			
strLiteral returns [Expr result]
	: STR { $result = new strLiteral($STR.text); }
	;

boolLiteral returns [Expr result]
	: BOOL { $result = new boolLiteral(Boolean.valueOf($BOOL.text)); }
	;

	
identifier returns [Expr result]
	: ID
	{   
		$result = new Identifier($ID.text);
	}
	;

orExpr returns [Expr result]
	:   lhs=andExpr { $result = $lhs.result; } ( '||' rhs=andExpr { $result = new Or($result, $rhs.result); } )*
	;

andExpr returns [Expr result]
	:   lhs=relExpr { $result=$lhs.result; } ( '&&' rhs=relExpr { $result = new And($result, $rhs.result); } )*
	;

relExpr returns [Expr result]
	:   lhs=addExpr { $result=$lhs.result; } ( op=('<'|'<='|'>'|'>='|'=='|'!=') rhs=addExpr 
		{ 
			switch($op.text){
				case "<":	$result = new LT($result, $rhs.result);
				case "<=":	$result = new LEq($result, $rhs.result); 
				case ">":	$result = new GT($result, $rhs.result); 
				case ">=":	$result = new GEq($result, $rhs.result); 
				case "==":	$result = new Eq($result, $rhs.result);
				case "!=":	$result = new NEq($result, $rhs.result);
			}
		})*
	;

// Tokens
COMMENT 		:   '/*' .*? '*/' -> channel(HIDDEN);
LINE_COMMENT 	:   '//' ~[\r\n]* -> channel(HIDDEN);
WS  	:	(' ' | '\t' | '\n' | '\r') -> channel(HIDDEN);

BOOLEAN :   'bool';
INTEGER :   'int';
STRING  :   'str';

ID		:	('a'..'z'|'A'..'Z')('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;
BOOL	:	'true' | 'false';
INT		:   ('0'..'9')+;
STR 	:   '"' .*? '"';
